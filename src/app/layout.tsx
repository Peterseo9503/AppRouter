import Link from "next/link";

export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <header>
          <Link href={"/"}>index</Link>
          &nbsp;
          <Link href={"/search"}>search</Link>
          &nbsp;
          <Link href={"/book/1"}>book/1</Link>
        </header>
        {children}
      </body>
    </html>
  );
}

//라우트 그룹 () 소괄호안에 넣는거, 경로에 어떠한 영향을 미치지 않음.
//하나의 폴더안에 묶어줄수있다. 경로상에 영향을 미치지않으면, 원하는 페이지에 레이아웃을 먹이고 싶으면
//리액트 서버 컴포넌트란?
/**
 *
 * 서버 컴포넌트 이전의 이야기 (등장배경)
 * FCP , TTI
 * TTI를 위한 컴포넌트와 상호작용이 필요없는 컴포넌트들이 있었다.
 * 상호작용이 없는 컴포넌트들은 하이드레이션을 굳이 필요없었다. (페이지 라우트 시절)
 *
 * 브라우저에서 상호작용이 필요없는 얘들을 JS번들에서 제외시키면된다.
 * 그래서 나온것이 React Server Component 서버측에서만 실행되는 컴포넌트!
 * 상호작용이 필요없는 컴포넌트들을 서버컴포넌트로 분류한다.
 * 상호작용이 필요한 얘들을 클라이언트 컴포넌트로 분류
 *
 * 상호작용의 유무에따라서 서버컴포넌트, 클라이언트 컴포넌트로 분류해야한다.
 * 서버클라이언트는 1번, 클라이언트는 2번( JS번들 할때 )
 *
 * 앱라우터는 기본적으로 서버컴포넌트를 지원한다.
 *
 */

//리액트 훅스는 브라우저에서만 발동한다. 그래서 서버컴포넌트에서 실행하면 오류가 발생한다.

// 디렉티브 설정해줘야함. "use client";

// co-Location

/**
 * 서버 컴포넌트 주의 사항
 * 1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되며 안된다. ( 리액트 훅들, 라이브러리 역시 사용 불가능 )
 * 2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지않는다.
 * 3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import할수없다. 임포트하려는 컴포넌트가 서버컴포넌트인지, 클라이언트 컴포넌트인지 확인해야한다.!!
 *  - 만약 서버컴포넌트를 클라이언트 컴포넌트를 불러온다면, 그냥 서버컴포넌트를 클라이언트 컴포넌트로 해석해서 실행시킴
 *  - 클라이언트 컴포넌트에서 서버컴포넌트를 받아올때, props children을 사용해서 받아오자.
 * 4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가능하다.
 * 직렬화 (Serialization) 객체, 배열, 클레스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태로 변환하는것
 * Before cosnt person = {name:"서동현", age:31}-> {"name":"서동현", "age":31} serialization
 * 자바스크립트 함수는 직렬화가 불가능함.
 * RSC Payload react server component 페이로드 -> 순수한 결과물
 */
